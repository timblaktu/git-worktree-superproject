#!/usr/bin/env bash
# workspace - Manage multi-repo workspaces without submodules

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# The workspace root is where we're running from, not where the script is
WORKSPACE_ROOT="$(pwd)"
CONFIG_FILE="$WORKSPACE_ROOT/workspace.conf"
REPOS_DIR="$WORKSPACE_ROOT/repos"
WORKTREES_DIR="$WORKSPACE_ROOT/worktrees"

# Initialize superproject if needed
init_superproject() {
    if [[ ! -d "$WORKSPACE_ROOT/.git" ]]; then
        echo "Initializing workspace superproject..."
        cd "$WORKSPACE_ROOT"
        git init
        git config extensions.worktreeConfig true
        echo "/repos/" >> .gitignore
        echo "/worktrees/" >> .gitignore
        git add .
        git commit -m "Initialize workspace superproject"
        cd - > /dev/null
    elif [[ "$(cd "$WORKSPACE_ROOT" && git config extensions.worktreeConfig)" != "true" ]]; then
        echo "Enabling worktree config..."
        (cd "$WORKSPACE_ROOT" && git config extensions.worktreeConfig true)
    fi
}

# Load repository URLs from config file (legacy)
load_repos_from_file() {
    local repos=()
    [[ ! -f "$CONFIG_FILE" ]] && return
    
    # Use a different approach that handles files without final newlines
    # Read the entire file, then process line by line
    local content
    content=$(<"$CONFIG_FILE")
    
    # Handle empty file or whitespace-only content
    [[ -z "$content" ]] && return
    [[ -z "${content//[[:space:]]/}" ]] && return
    
    # Process each line, including the last one even without newline
    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        repos+=("$line")
    done <<< "$content"
    
    [[ ${#repos[@]} -gt 0 ]] && printf '%s\n' "${repos[@]}"
}

# Load repository URLs from multi-source configuration
load_repos() {
    local workspace="${1:-main}"
    
    # Priority 1: Worktree-specific git config
    if [[ -e "$WORKTREES_DIR/$workspace/.git" ]]; then
        local config
        config=$(cd "$WORKTREES_DIR/$workspace" 2>/dev/null && \
                 git config --worktree --get-all workspace.repo 2>/dev/null || true)
        if [[ -n "$config" ]]; then
            echo "$config"
            return
        fi
    fi
    
    # Priority 2: Superproject default config
    local default_config
    default_config=$(cd "$WORKSPACE_ROOT" && git config --get-all workspace.repo 2>/dev/null || true)
    if [[ -n "$default_config" ]]; then
        echo "$default_config"
        return
    fi
    
    # Priority 3: Legacy workspace.conf (for migration)
    if [[ -f "$CONFIG_FILE" ]]; then
        load_repos_from_file
    fi
}

# Extract repo name from URL
get_repo_name() {
    local url="$1"
    basename "${url%.git}"
}

# Ensure central repository exists
ensure_central_repo() {
    local url="$1"
    local name="$2"
    local central_repo="$REPOS_DIR/$name"
    
    if [[ ! -d "$central_repo" ]]; then
        echo "  Initializing central repository: $name"
        mkdir -p "$REPOS_DIR"
        if ! git clone "$url" "$central_repo" --quiet; then
            echo "  Error: Failed to clone $url" >&2
            return 1
        fi
        
        # Check out a placeholder branch so main branches can be used by worktrees
        (cd "$central_repo" && git checkout --orphan __workspace_placeholder 2>/dev/null && git reset --hard 2>/dev/null || true)
    fi
}

# Create worktree from central repository
create_worktree() {
    local name="$1"
    local branch="$2"
    local worktree_path="$3"
    local central_repo="$REPOS_DIR/$name"
    
    # Ensure the central repo is up to date (skip for local repos)
    if (cd "$central_repo" && git remote get-url origin 2>/dev/null | grep -qE "^(https?://|git@|ssh://)"); then
        (cd "$central_repo" && git fetch --all --quiet 2>/dev/null || true)
    fi
    
    # Check if the branch exists (locally or remotely)
    local branch_exists=false
    if (cd "$central_repo" && git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null); then
        # Local branch exists
        branch_exists=true
    elif (cd "$central_repo" && git show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null); then
        # Remote branch exists, create local tracking branch and worktree
        if (cd "$central_repo" && git worktree add "$worktree_path" -b "$branch" "origin/$branch" --quiet 2>/dev/null); then
            return 0
        fi
    fi
    
    if [[ "$branch_exists" == true ]]; then
        # Try to create worktree with existing local branch
        if (cd "$central_repo" && git worktree add "$worktree_path" "$branch" --quiet 2>/dev/null); then
            return 0
        fi
    else
        # Branch doesn't exist, create new branch from the default branch
        local default_branch
        default_branch=$(cd "$central_repo" && git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
        
        if (cd "$central_repo" && git worktree add "$worktree_path" -b "$branch" "$default_branch" --quiet 2>/dev/null); then
            return 0
        fi
    fi
    
    # All attempts failed
    echo "  Error: Failed to create worktree for branch $branch" >&2
    return 1
}

# Remove worktree
remove_worktree() {
    local name="$1"
    local worktree_path="$2"
    local central_repo="$REPOS_DIR/$name"
    
    if [[ -d "$central_repo" && -d "$worktree_path" ]]; then
        (cd "$central_repo" && git worktree remove "$worktree_path" --force 2>/dev/null || true)
    fi
}

# Switch to workspace (create if doesn't exist)
switch_workspace() {
    local branch="${1:-main}"
    local workspace_dir="$WORKTREES_DIR/$branch"
    local failed=0
    
    # Initialize superproject if needed
    init_superproject
    
    echo "Switching to workspace: $branch"
    
    # Create superproject worktree (not just directory)
    if [[ ! -e "$workspace_dir/.git" ]]; then
        echo "Creating workspace as superproject worktree..."
        mkdir -p "$WORKTREES_DIR"
        
        # Check if workspace branch exists
        if (cd "$WORKSPACE_ROOT" && git show-ref --verify --quiet "refs/heads/workspace/$branch" 2>/dev/null); then
            # Branch exists, just add worktree
            (cd "$WORKSPACE_ROOT" && git worktree add "$workspace_dir" "workspace/$branch" 2>/dev/null)
        else
            # Create new branch for this workspace
            (cd "$WORKSPACE_ROOT" && git worktree add "$workspace_dir" -b "workspace/$branch" 2>/dev/null)
        fi
    fi
    
    while read -r repo_line; do
        read -ra parts <<< "$repo_line"
        local url="${parts[0]}"
        local repo_branch="${parts[1]:-$branch}"
        local ref="${parts[2]:-}"
        local name=$(get_repo_name "$url")
        local repo_path="$workspace_dir/$name"
        
        [[ -d "$repo_path" ]] && { echo "  $name exists, skipping"; continue; }
        
        echo "  Setting up $name... (url=$url, branch=$repo_branch, path=$repo_path)"
        if ! ensure_central_repo "$url" "$name"; then
            echo "  Failed to set up central repository for $name" >&2
            failed=1
            continue
        fi
        echo "  Central repo for $name ready, creating worktree..."
        if ! create_worktree "$name" "$repo_branch" "$repo_path"; then
            echo "  Failed to create worktree for $name" >&2
            failed=1
            continue
        fi
        echo "  Worktree for $name created successfully"
        
        [[ -n "$ref" ]] && (cd "$repo_path" && git checkout "$ref" --quiet)
    done < <(load_repos "$branch")
    
    if [[ $failed -eq 1 ]]; then
        echo "Workspace setup completed with failures" >&2
        exit 1
    fi
    
    echo "Workspace ready: $workspace_dir"
}

# Sync workspace
sync_workspace() {
    local branch="${1:-$(basename "$PWD")}"
    local workspace_dir="$WORKTREES_DIR/$branch"
    
    [[ ! -d "$workspace_dir" ]] && { echo "Workspace not found: $branch"; exit 1; }
    
    echo "Syncing workspace: $branch"
    
    while read -r repo_line; do
        read -ra parts <<< "$repo_line"
        local url="${parts[0]}"
        local ref="${parts[2]:-}"
        local name=$(get_repo_name "$url")
        local repo_path="$workspace_dir/$name"
        
        [[ ! -d "$repo_path" ]] && continue
        
        if [[ -n "$ref" ]]; then
            echo "  $name is pinned, skipping"
        else
            echo "  Updating $name..."
            # Update central repository first
            local central_repo="$REPOS_DIR/$name"
            [[ -d "$central_repo" ]] && (cd "$central_repo" && git fetch --all --quiet)
            # Then update the worktree
            (cd "$repo_path" && git pull --ff-only)
        fi
    done < <(load_repos "$branch")
}

# Show status
show_status() {
    echo "Workspace Status"
    echo "================"
    
    [[ ! -d "$WORKTREES_DIR" ]] && { echo "No workspaces found"; return; }
    
    for workspace_dir in "$WORKTREES_DIR"/*; do
        [[ ! -d "$workspace_dir" ]] && continue
        
        local workspace=$(basename "$workspace_dir")
        echo -e "\n$workspace"
        echo "----------------------------------------"
        
        while read -r repo_line; do
            read -ra parts <<< "$repo_line"
            local url="${parts[0]}"
            local name=$(get_repo_name "$url")
            local repo_path="$workspace_dir/$name"
            
            [[ ! -d "$repo_path" ]] && { printf "  %-20s [missing]\n" "$name:"; continue; }
            [[ ! -d "$repo_path/.git" && ! -f "$repo_path/.git" ]] && { printf "  %-20s [invalid git]\n" "$name:"; continue; }
            
            (
                cd "$repo_path"
                local branch=$(git branch --show-current || git describe --always)
                local status=$(git status --porcelain)
                printf "  %-20s %-20s %s\n" "$name:" "$branch" "[$([ -n "$status" ] && echo "modified" || echo "clean")]"
            )
        done < <(load_repos "$workspace")
    done
}

# Execute command in all repos (like git submodule foreach)
foreach_repos() {
    shift  # Remove 'foreach' from arguments
    
    local quiet=false
    if [[ "$1" == "--quiet" || "$1" == "-q" ]]; then
        quiet=true
        shift
    fi
    
    local workspace_branch="$(basename "$PWD")"
    local workspace_dir="$WORKTREES_DIR/$workspace_branch"
    [[ ! -d "$workspace_dir" ]] && { echo "Not in workspace"; exit 1; }
    while read -r repo_line; do
        read -ra parts <<< "$repo_line"
        local url="${parts[0]}"
        local name=$(get_repo_name "$url")
        local repo_path="$workspace_dir/$name"
        local displaypath="${repo_path#$workspace_dir/}"
        
        if [[ -d "$repo_path/.git" || -f "$repo_path/.git" ]]; then
            # Export variables like git submodule foreach
            export name="$name"
            export path="$displaypath"
            export displaypath="$displaypath"
            export toplevel="$workspace_dir"
            
            if [[ "$quiet" == false ]]; then
                echo "=== $name ==="
            fi
            (cd "$repo_path" && eval "$@")
            if [[ "$quiet" == false ]]; then
                echo
            fi
        fi
    done < <(load_repos "$workspace_branch")
}

# List workspaces
list_workspaces() {
    echo "Available Workspaces"
    echo "==================="
    
    [[ ! -d "$WORKTREES_DIR" ]] && { echo "No workspaces found"; return; }
    
    for workspace_dir in "$WORKTREES_DIR"/*; do
        [[ -d "$workspace_dir" ]] && echo "  $(basename "$workspace_dir")"
    done
}

# Clean workspace
clean_workspace() {
    local branch="${1}"
    [[ -z "$branch" ]] && { echo "Workspace name required"; exit 1; }
    
    local workspace_dir="$WORKTREES_DIR/$branch"
    [[ ! -d "$workspace_dir" ]] && { echo "Workspace not found: $branch"; exit 1; }
    
    echo "Delete workspace: $branch? (y/N) "
    read -r -n 1
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo "Removing worktrees..."
        while read -r repo_line; do
            read -ra parts <<< "$repo_line"
            local url="${parts[0]}"
            local name=$(get_repo_name "$url")
            local repo_path="$workspace_dir/$name"
            
            [[ -d "$repo_path" ]] && remove_worktree "$name" "$repo_path"
        done < <(load_repos "$branch")
        
        # Remove superproject worktree
        if [[ -e "$workspace_dir/.git" ]]; then
            (cd "$WORKSPACE_ROOT" && git worktree remove "$workspace_dir" --force 2>/dev/null || true)
        else
            # Legacy: Remove the workspace directory after all worktrees are removed
            rmdir "$workspace_dir" 2>/dev/null || rm -rf "$workspace_dir"
        fi
        echo "Workspace removed"
    else
        echo "Cancelled"
    fi
}

# Config management: Set repository configuration for a workspace
config_set() {
    local workspace="${1:-}"
    local repo_spec="${2:-}"
    
    [[ -z "$workspace" || -z "$repo_spec" ]] && { 
        echo "Usage: workspace config set <workspace> <url> [branch] [ref]" 
        echo "       workspace config set <workspace> <repo-name> <url> [branch] [ref]"
        exit 1 
    }
    
    shift 2
    local remaining_args=("$@")
    
    # Parse arguments - could be either:
    # 1. <url> [branch] [ref]
    # 2. <repo-name> <url> [branch] [ref]
    local url branch ref repo_name
    
    if [[ "$repo_spec" =~ ^https?:// || "$repo_spec" =~ ^git@ || "$repo_spec" =~ ^ssh:// || "$repo_spec" =~ \.git$ ]]; then
        # First arg is URL
        url="$repo_spec"
        branch="${remaining_args[0]:-main}"
        ref="${remaining_args[1]:-}"
        repo_name=$(get_repo_name "$url")
    else
        # First arg is repo name
        repo_name="$repo_spec"
        url="${remaining_args[0]:-}"
        branch="${remaining_args[1]:-main}"
        ref="${remaining_args[2]:-}"
        
        [[ -z "$url" ]] && { echo "URL required when specifying repo name"; exit 1; }
    fi
    
    local workspace_dir="$WORKTREES_DIR/$workspace"
    
    # Ensure workspace exists as git worktree
    if [[ ! -e "$workspace_dir/.git" ]]; then
        echo "Workspace '$workspace' does not exist or is not a git worktree"
        echo "Create it first with: workspace switch $workspace"
        exit 1
    fi
    
    # Store in git config
    local config_value="$url $branch${ref:+ $ref}"
    (cd "$workspace_dir" && git config --worktree "workspace.repo" "$config_value")
    
    echo "Set repository config for workspace '$workspace':"
    echo "  $repo_name: $config_value"
}

# Config management: Show workspace configuration
config_show() {
    local workspace="${1:-main}"
    
    echo "Configuration for workspace: $workspace"
    echo "======================================="
    
    # Check worktree-specific config
    if [[ -e "$WORKTREES_DIR/$workspace/.git" ]]; then
        local worktree_config
        worktree_config=$(cd "$WORKTREES_DIR/$workspace" 2>/dev/null && \
                         git config --worktree --get-all workspace.repo 2>/dev/null || true)
        if [[ -n "$worktree_config" ]]; then
            echo "Workspace-specific repositories:"
            echo "$worktree_config" | while IFS= read -r line; do
                echo "  $line"
            done
            return
        fi
    fi
    
    # Check default config
    local default_config
    default_config=$(cd "$WORKSPACE_ROOT" && git config --get-all workspace.repo 2>/dev/null || true)
    if [[ -n "$default_config" ]]; then
        echo "Default repositories (inherited):"
        echo "$default_config" | while IFS= read -r line; do
            echo "  $line"
        done
        return
    fi
    
    # Check legacy file
    if [[ -f "$CONFIG_FILE" ]]; then
        echo "Legacy configuration (from workspace.conf):"
        load_repos_from_file | while IFS= read -r line; do
            echo "  $line"
        done
        return
    fi
    
    echo "No configuration found"
}

# Config management: Import from workspace.conf
config_import() {
    local workspace="${1:-}"
    local source_file="${2:-$CONFIG_FILE}"
    
    [[ -z "$workspace" ]] && { echo "Workspace name required"; exit 1; }
    [[ ! -f "$source_file" ]] && { echo "Config file not found: $source_file"; exit 1; }
    
    local workspace_dir="$WORKTREES_DIR/$workspace"
    
    # Ensure workspace exists as git worktree
    if [[ ! -e "$workspace_dir/.git" ]]; then
        echo "Creating workspace as superproject worktree..."
        init_superproject
        mkdir -p "$WORKTREES_DIR"
        
        if (cd "$WORKSPACE_ROOT" && git show-ref --verify --quiet "refs/heads/workspace/$workspace" 2>/dev/null); then
            (cd "$WORKSPACE_ROOT" && git worktree add "$workspace_dir" "workspace/$workspace" 2>/dev/null)
        else
            (cd "$WORKSPACE_ROOT" && git worktree add "$workspace_dir" -b "workspace/$workspace" 2>/dev/null)
        fi
    fi
    
    echo "Importing configuration to workspace: $workspace"
    
    # Clear existing workspace-specific config
    (cd "$workspace_dir" && git config --worktree --unset-all workspace.repo 2>/dev/null || true)
    
    # Import from file
    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        
        (cd "$workspace_dir" && git config --worktree --add "workspace.repo" "$line")
        echo "  Imported: $line"
    done < "$source_file"
    
    echo "Import complete"
}

# Config management: Set default configuration
config_set_default() {
    local repo_spec="${1:-}"
    
    [[ -z "$repo_spec" ]] && { 
        echo "Usage: workspace config set-default <url> [branch] [ref]" 
        exit 1 
    }
    
    shift
    local remaining_args=("$@")
    
    # Parse arguments
    local url="$repo_spec"
    local branch="${remaining_args[0]:-main}"
    local ref="${remaining_args[1]:-}"
    
    # Initialize if needed
    init_superproject
    
    # Store in superproject git config
    local config_value="$url $branch${ref:+ $ref}"
    (cd "$WORKSPACE_ROOT" && git config --add "workspace.repo" "$config_value")
    
    echo "Set default repository config:"
    echo "  $config_value"
}

# Main
case "${1:-help}" in
    switch) switch_workspace "${2:-main}" ;;
    sync)   sync_workspace "${2:-}" ;;
    status) show_status ;;
    foreach) foreach_repos "$@" ;;
    list)   list_workspaces ;;
    clean)  clean_workspace "${2:-}" ;;
    config)
        case "${2:-}" in
            "")
                echo "Error: config command requires a subcommand" >&2
                echo "Run 'workspace config help' for usage information" >&2
                exit 1
                ;;
            set) 
                shift 2
                config_set "$@" 
                ;;
            show)
                config_show "${3:-main}"
                ;;
            import)
                config_import "${3:-}" "${4:-}"
                ;;
            set-default)
                shift 2
                config_set_default "$@"
                ;;
            help)
                cat << EOF
Configuration Management

Usage: workspace config <subcommand> [arguments]

Subcommands:
  set <workspace> <url> [branch] [ref]
                    Set repository config for a workspace
  show [workspace]  Show configuration (default: main)
  import <workspace> [file]
                    Import from workspace.conf file
  set-default <url> [branch] [ref]
                    Set default repository for all workspaces

Configuration Priority:
  1. Workspace-specific (git worktree config)
  2. Default (superproject git config)
  3. Legacy workspace.conf file (migration only)
EOF
                ;;
            *)
                echo "Error: Unknown config subcommand: ${2}" >&2
                echo "Run 'workspace config help' for usage information" >&2
                exit 1
                ;;
        esac
        ;;
    help|*)
        cat << EOF
Workspace Manager - Submodule-free multi-repo development

Usage: workspace <command> [arguments]

Commands:
  switch [branch]   Switch to workspace, create if needed (default: main)
  sync [branch]     Sync repositories
  status            Show all workspace status
  foreach <cmd>     Execute command in all repos
  list              List workspaces
  clean <branch>    Remove workspace
  config            Manage per-workspace configurations

Configuration:
  Per-workspace: Use 'workspace config' commands
  Legacy: Edit workspace.conf (for backward compatibility)

Examples:
  workspace switch feature-x
  workspace config set feature-x https://github.com/org/repo.git feature-branch
  workspace config show feature-x
  workspace config import main workspace.conf
EOF
        ;;
esac